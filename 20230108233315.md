# Linux で動かしながら学ぶ TCP/IP ネットワーク入門

#linux #tcp/ip


# Environment

M1 macOS では virtual box, vmware が対応してないので、仮想マシンを立ち上げるのが難しい

- multipass
- docker

# Install Commands

```sh
sudo apt-get -y install bash coreutils grep iproute2 iputils-ping traceroute tcpdump bind9-dnsutils dnsmasq-base netcat-openbsd python3 curl wget iptables procps isc-dhcp-client
```

# TCP/IP

- TCP = Transmission Control Protocol. データ転送の保証をするプロトコル(ヘッダーなど)
- IP = Internet Protocol. LANでつながったRouterをHopしていき、宛先までデータを届けるプロトコル
- Node = Router or Host(Routerではないコンピュータ). 木の幹に例えられる
- Ethernet = 富士ゼロックスの商標. 有線LANの規格
  - 物理層
  - データリンク層
- ICMP = Internet Control Message Protocol
  - ping に使う(echo request / echo reply)
  - もしくはエラーの通知など
  - IPによって運ばれる
- プロトコルの組み合わせ
  - IP のヘッダーの最後はPayload = data
  - data に他のプロトコルのヘッダーから始まるバイト列を入れることで、プロトコルを組み合わせられる(TCP header => Protocol に使うプロトコルを書いておく)
- Network Interface = NICカード(LAN)、Wi-fiアンテナモジュールなど、コンピューターから外部のネットへの出入り口のデバイスのこと
  - 番号、ID、名前が振られる
- パケットキャプチャ、スニッフィング = tcpdump, 通信の監視のこと
- ブロードバンド = 現在主流の回線帯域。ナローバンドをわざわざ使っているところは、普及が遅れているか設備をケチっている
- ブロードバンドルーター






# Linux command

- ping [addr]
  - -c : count
  - rtt = Round Trip Time
- traceroute [addr]
  - ttl を 1,2,3...と増やしつつリクエストを投げていって、ICMP replyで帰ってきたrouter のIPアドレス情報をプリントしていくという仕組み
  - -n : アドレスの名前を解決しないで、IPアドレスをそのまま表示する(no-name)
  - -h : ホップ数 (ttl = time to live 回数)
  - -f : first ttl. これを設定した回のルーター情報からリストが始まる
- tcpdump [protocol]
  - -t : 時刻を省く
  - -n : IPアドレスを逆引きしない
  - -i any : すべてのNetwork Interfaceの入出力を監視

# インターネット = バケツリレー

- パケット道順 = 通過するルーター機器
- Route = どのルーターを通ったか
  - traceroute のリストの最初と最後以外は全部router

- 家のLANからグローバルネットへの出口
  - モバイル回線(スマホ)
  - ブロードバンド回線(Router, 光コンセントのOCU)

- routing table
  - router がパケットを投げる先の候補
  - default : IP ヘッダの宛先がテーブルに無いときに投げる宛先

# ip command 

```sh
ip route show
```

ルーティングテーブルを表示する
結果の見方

```
default via 192.168.64.1 dev enp0s1 proto dhcp src 192.168.64.2 metric 100 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown
```
たくさん列があるが見るのは一部

- ルーティングエントリ = 行
  - 2大要素
  - dist = 最終目標アドレス
  - next Hop = 次に渡す宛先の候補

上の例だと
- default, 172.17.0.0./16 = next hop list
  - これら２つは、複数のIPをまとめた書き方である
    - default = 他の宛先に当てはまらないものすべて
    - x.x.x.x/16 = 32 ビット中、サブネットマスクされた下16ビットを無視し、上16ビットが一致する宛先の場合にここに送る(つまりサブネット)


# Static Routing 

```sh
sudo ip netns exec router1 add route x.x.x.0/24 via y.y.y.y
```

あるネットワークアドレス向けのリクエストを、viaで指定したアドレスに経由するルーティングエントリーをルーティングテーブルに追加する

この時、ip link add で作ってある veth のペアは既にルーティングテーブルに追加されている
なので y.y.y.y はrouter2のveth IP アドレスを指定する

なお、このように手動でルートを追加するのStatic Routingといい、
世の中で使われているルータは基本的に動作中にBGP, OSPF などのルーティング情報を交換して自動的にRouting tableを更新している(Dynamic routing)


# Ethernet
プロトコルを含んだ規格
イーサネットはIPより下のデータリンク・物理層

IPパケット = 荷物
  - IPヘッダー = ダンボール
  - IPペイロード = 中身(ICMP, HTTP, TCP など)
イーサネットフレーム = トラック1台

## イーサネットの通信
MACアドレス : 48bit の数値、ハードウェアアドレスとも言う. コンピュータに振られるid
前半24 はベンダーに振られる

広い世界ではかぶることもありうるが、ブロードキャストドメインでかぶりさえしなければ問題ない(大体LANにつながる機器は多くて20以下)

## MACアドレス

ハードウェアごとに振られるが、実質的には Ethernet のNICに振られる
(つまりLANカードやWi-fiアンテナモジュール)

ping を打つ時、IPアドレスしか指定しないがMACアドレスの情報を取得できる
これは Adress Resolution Protocol (ARP) があるので、IPアドレスに対応するMACアドレスを解決できるためである。
(基本、IPアドレス+MACアドレスでセットになる)

tcpdumpでARPを観察する
```sh
sudo ip netns exec ns1 tcpdump -tnel -i ns1-veth0 icmp or arp
```

or を使うと、プロトコルを複数観察できる

## ARP

IPアドレスに向けた通信を行う前に、対応するMACアドレスを知りたい
ネットワーク全体にブロードキャストして探す


1. ff:ff:ff:ff:ff:ff (ブロードキャストMACアドレス)に ARP request. 自身のMACアドレスとIPアドレス、要求するMACアドレスに対応すると思われるIPアドレスを送る
2. 受けた機器のうち、要求されているMACアドレスと対応するIPを持っていたら、返信する. ARP reply

このリクエストの結果はキャッシュされる
MACアドレスとIPアドレスの紐付けは滅多には変わらないので。

IPv4 ではこの方法でMACアドレスを探すが、IPv6ではICMPの近隣探索を使う

ARPは Ethernet ヘッダーで送られる


## Ethernet プロトコル

Ehternet Header > IP ヘッダー > IP ペイロード
の順でビットが並ぶ

プロトコルの組み合わせ

## パケット積替えられる

ブロードキャストドメインの範囲はサブネットと同じ
その範囲外のMACアドレスに届ける場合では、届け先の最終地点(HOST)のMACアドレスを知る必要はない。

ns1 -> router1 -> router2 -> ns2
この経路だと、ns1のrouting tableには default via router1 が書かれている。
つまり、ns1 は router1 のMACアドレスを知る必要があり、
router1 は router2 の、router2 は ns2 のそれを知っていればいい。
なので、ARPリクエストをブロードキャストする範囲のMACアドレスだけ知っていれば通信できる(リレー形式)

IPパケットを送る場合、IPヘッダーにMACアドレスを入れるところはない。
Ethernet ヘッダーにある。
つまり、Ethernet ヘッダーはサブネットを超えた先に届くたびに書き換えられて次のハードウェアへのMACアドレスに書き換わる
(集積所で、荷物を載せ替えるようなイメージ)


# ブリッジ

veth インターフェースは 2 つのNICがペアになって動作する。
現実世界にはスイッチングハブがある。
(ルーターがスイッチングハブを内蔵していることもある)

スイッチングハブを一般化した言葉が `ブリッジ`

ブリッジ = つながっている機器のMACアドレス情報を収集・管理しておき、Ethernetパケット(フレーム)が来たら機器がつながっているポートにフレームを送信する
MACアドレステーブルという、Routing table のようなものを持つ
いわば物理層のルーター


## MACアドレステーブル

ARPで学習した内容が記録されていく
どのインターフェース(ethなど)の先にMACアドレスを持つハードウェアが存在するかの対応表

Ethernet レイヤーの通信でのブリッジによるパケット振り分けのため参照される

## スイッチングハブ vs リピーターハブ
古い&非効率 = リピーター
新しい&効率的 = スイッチング

以前はリピーターハブが普及していた
やってることは同じだが動作原理が違う
リピータハブはMACアドレステーブルなどを持たず、自身につながっているすべてのポートにパケットをコピーして繰り返し送る
自分宛てでないパケットは受取先で捨てられるので、動作的には問題ないが通信量が無駄すぎる

ただし、スイッチングハブで転送されるデータを別のコンピュータから参照するのには便利でローカルデバッグで優位性があったときもある
(スイッチングハブにミラーリングポートがついてればそれで再現できる)


# トランスポート層プロトコル

ここまでは届けるまでのプロトコル(Ethernet, IP)

ただ、パケットやフレームが途中で捨てられることもありうる
確実に通信するには、捨てられたと判断したら再送を要求する必要があるということ。
それを解決するのはトランスポート層プロトコル


## UDP

TCP とくらべるとプロトコルが単純

Ethernet Header + IP Header + UDP Header + UDP payload ...


UDPヘッダーの内容には、データをどのアプリケーションで利用するかという情報を入れるフィールドが含まれる
それが port フィールド

# port

TCP / UDP で使う概念
IPアドレスがネットワーク上におけるホストの住所とすると、port はホストの中の部屋番号 (ネットワークを使うアプリケーション番号)
IP = 住所
Port = 部屋番号

基本的にportは別のアプリケーションと共用できない
well known port を避けるようにする


## UDP Header 
- source port(16bit)
- destination port(16bit)
- length(16bit)
- checksum(16bit)
- Data ...

非常にシンプル
送り元のポートは、多分返信に使う

ただ、送り元のIPアドレスはヘッダに書いてない
Data に入れることもできる
(HTTPとかだと Origin ヘッダーに書いてる)

IPヘッダに送り元のアドレスはあるから、もしやるとしたら二重情報になるが

### なぜ source port ?
サーバー側はStaticにportを決められるが、クライアント側から通信を始めようとするとOSが余ってるポートを割り当てることが多い。
クライアント側のportは動的に変わるので、返信先の情報として逐一送る必要があるが
(OSが動的に割り当てるポート = Ephemeral Port)

### UDPの問題

UDPはトランスポート層プロトコルではあるが、コネクションレス型であり
送ったら送りっぱなし、到達の確認はしないというプロトコル。

経路上のパケットの破棄に関知しないので、信頼性のある通信は更に上位層のプロトコルを使う
(UDPを使って再送などを実装した信頼性の高い上位レイヤープロトコルもある)

# TCP
Transmission Control Protocol
再送制御を持ち、信頼性のある通信

コネクション型通信とも言う


## out of order
順番通りじゃない

IPで届けられるTCPデータは細切れで送ったりするので、到着順が変わることもある
TCPはそれを見越して、データの断片に順番を付けて到着先で組み立てるので大丈夫

TCP は UDP と同じく、多くのアプリケーション層プロトコルの下位層に使われる
(UDPを下位にするプロトコルは、リアルタイム性が重要)

## TCPハンドシェイク

セグメント = TCP でやり取りするデータの範囲
開始時に3つのセグメントをやり取りする

three way handshake
これが完了するとTCPコネクションが確立したとみなされる

### コントロールビット

TCPヘッダに含まれる6bitのフラグ
tcpdumpのログにもでる

```sh
... Flags [S], ...
... Flags [S.] ...
... Flags [.] ...
```

S = SYN、Synchronize sequence numbers、データに連続性のある番号をつけて送るため、その番号を同期する
. = ACK、Acknowledgement field significant、ACKフラグのたったセグメントを送るとことでデータを受け取ったことを示す。これが帰ってこないときは同じセグメントを何度か再送する。
P = PSH、Push Function. TCPは効率性のためデータをバッファするが、溜まってくると操作性に悪影響を及ぼすので今すぐ処理するよう指示するフラグ(ストリーミングとか？)


Acknowledgement = 周知

3 way shake では
クライアント -> SYN -> サーバー
サーバー -> SYN + ACK -> クライアント
クライアント -> ACK -> サーバー

この通信が完了したらハンドシェイク完了
要約すると
クライアント: シーケンス番号同期して！
サーバー: 同期したよ！そっちも同期して！
クライアント: 同期したよ！

### 具体的なパケット

```sh
hello\n

# 送るよ！長さはこれで全部だからすぐ使って (PSH, ACK)
IP 127.0.0.1.40828 > 127.0.0.1.54321: Flags [P.], seq 1:7, ack 1, win 512, options [nop,nop,TS val 985936206 ecr 985934384], length 6

# 受け取ったよ！ ack = 25 は今まで通信した長さの合計だよ！
IP 127.0.0.1.54321 > 127.0.0.1.40828: Flags [.], ack 7, win 512, options [nop,nop,TS val 985936206 ecr 985936206], length 0

world\n
# クライアント側のseq, サーバー側の ack が増えている
IP 127.0.0.1.40828 > 127.0.0.1.54321: Flags [P.], seq 7:13, ack 1, win 512, options [nop,nop,TS val 985993829 ecr 985936206], length 6
IP 127.0.0.1.54321 > 127.0.0.1.40828: Flags [.], ack 13, win 512, options [nop,nop,TS val 985993829 ecr 985993829], length 0

```
TCPはコネクション型なので、一回の通信を切らない限り seq と ack はどんどん増えていく
これらは送るデータの長さを表す

1コネクション = netcat コマンドを終了するまで

netcat ではわかりやすさのため、seqは 1 から始まるが、実際のアプリケーションではサイバー攻撃から狙われないようランダムなシーケンス番号から始めることが多い

# アプリケーション層プロトコル

- HTTP
- DNS
- DHCP

TCP/IPを理解するのに重要なプロトコル3つ

## Hyper Text Transfer Protocol

テキストベースプロトコル
Header(key:value, 改行区切り)
Payload

からなる

## HTTP Request

netcat コマンドにパイプで標準入力することで、HTTPリクエスト内容をTCPで投げられる

```http
GET / HTTP/1.0


```
localhost:80/ に GET リクエストするペイロード

```sh
echo -en "GET / HTTP/1.0\r\n\r\n" | nc 127.0.0.1 80
```

この、2回改行するというのはHTTPリクエストデータで重要なことらしい
\r\n じゃなくて \n 二回でも行けた

### URI?

https://... みたいな文字列が登場しなかった
これは、netcatコマンドでアドレスとポートを打ってるので不要だった

### HTTP2, 3 との違い
バイナリベースだったり、UDPの上のレイヤーに実装されてたりと
TCPのテキストベースであるHTTP1 とかなり違うので今回と同じ方法では通信できない


# DNS
略語にPがついてないけどプロトコル
Domain Name System

ドメインをIPアドレスとして解決するプロトコル
google.comとか

hostname という言葉は、 x.x.x.x, example.com どちらも指す

localhost もドメイン名

## ドメインネームをIPアドレスへ解決する仕組

OSに含まれる Resolver というプログラムが担当している

1. /etc/hosts ファイルを参照
hosts ファイルはシンプルに IP address = domain name の組み合わせがスペース区切りのペアで書いてあるだけのシンプルなファイル
2. なかったら外部サーバーに問い合わせ


## ネームサーバー

ドメインネームとIPアドレスの紐付けを持っているサーバー
hostsファイルの外部サーバー版

## DNSフォワーダー
コンピューターのデフォルトネームサーバーが家庭のルーターになってることがある。
もちろんルーターがすべてのドメインとIPアドレスの組み合わせを持っているわけではなく、自動でDNSサーバーへの問い合わせを中継してくれるだけ

ユーザーがいちいちネームサーバーのアドレスを指定しなくていいのがメリット

## /etc/resolve.conf

リゾルバーの設定を書くファイル
デフォルトDNSサーバーとか、DNSフォワーダーの設定をする

## DNSサーバーの種類

- キャッシュサーバー
- コンテンツサーバー

PCで明示的に指定するのはキャッシュサーバーの方
コンテンツサーバーは普通にはアクセスできないと思われる

例. 8.8.8.8

# DHCP

Dynamic Host Configuration Protocol

家庭やオフィスのネットワークでかならず使う
コンピュータに対するTCP/IPネットワークの設定を自動化するためのプロトコル

- NICへのIPアドレス付与
- デフォルトルートのルーティングエントリをテーブルに追加
- DNSサーバーの設定

これらはインターネットの利用にかならず使うが、管理者がいちいち手動で設定するのは無理
DHCPはサーバー・クライアント方式のプロトコルで、設定を決めてくれるサーバーにクライアントが問い合わせる


これにより、ネットワークのユーザーはTCP/IP関連の設定コマンドを知らなくても、DHCPクライアントでDHCPサーバーに問い合わせれば自動で設定ができる

さらに言えば、一般家庭で言えば**ルーター**がDHCPサーバーで、PCのOSが自動的にDHCPクライアントを起動させて
ユーザーはDHCPの知識さえいらずにネットワークができるといえる

## インターネットゲートウェイ(ルーター)のグローバルIPの自動設定

家からグローバルにつながる入り口であるルーター
そのグローバルIPは一般には自動で設定される

DHCPを使っているところもあるが、多くの場合は違う
グローバルIPの決定にはPPPoE 及びそれに載せて送る IPCP というプロトコルによりアドレスが配布される
- Point-toPoint Protocol over Ethernet (PPPoE)
- Internet Protocol Control Protocol (IPCP) : DHCPと似た機能

IPv6 の場合は、PPPoE + DHCPv6


# NAT

Network Address Translation
プロトコルを指す言葉ではなく、IPアドレスを変換する概念

IPv4 アドレスは数に限りがあるので、グローバルでは一意だがローカルネットワークには新しくアドレスを使って変換してやりくりする
(IPv4 グローバルアドレスの節約)

## Reserved Private Address

LAN で使うために予約されているネットワークアドレス(つまりサブネットアドレス)
グローバルネットワークでは使えないことになっている

- 10.0.0.0/8
- 172.0.16.0/12
- 192.168.0.0/16

256, 4096, 65536 台の機器をそれぞれネットワークに繋げる



## Source NAT, Destination NAT

一般的な NAT, NAPT は Source NAT
基本はルータが実施する

送信先がグローバル、送信元がプライベートなアドレスの場合に書き換えを実行する
ルータ自身のインターフェースにはグローバルアドレスが付与されているのでそれに書き換える

また、行きだけではなく返りも同じく書き換えが必要
ただし、戻りの場合はグローバルIPをどのプライベートIPに変換するか、戻ったレスポンスだけでは判断できない(ルーターのグローバルIPとローカル機器のPrivate IP は 1:N の関係にあるため)
なので、行きのときにSource IPだけでなくSource port も書き換える
(PC -> Router のある特定のポートへ投げる)

ネットワーク層(IP)の Address だけでなく、トランスポート層(TCP/UDP)の Port も書き換えるので
NATは厳密にはNAPTであることがることが多い
Network Adress & Port Translation

(要するに、パケットやフレームのビットを書き換えてるということ)


NAPT で書き換えた後、書き換える前のアドレス、ポートの対応関係はルーターが覚えておく
戻ってきたら書き直す
(この管理をNAPTにおけるセッションと呼ぶ)


### NAT チェックサム

チェックサムは他のフィールドから計算されるビット値
内容が書き換えられていないことを証明するために使われる

ただ、NATでパケットヘッダのフィールドを書き換えるとチェックサムと合わなくなるので、
チェックサムを再計算して書き直すのもNATの内容の一つ



wan <=> lan
wide area network <=> local area network


## ICMP + NAT ?

ICMPはpingなどに使われる、疎通確認や経路の調査に使われるプロトコル
TCP/UDPと違って port フィールドは無いはず

だが、ICMPヘッダーには identifier フィールドがあり、それぞれの Request, Reply には id がある
NATはポートがない場合は他のフィールドを使って1:Nの変換を試みる


### インターネットレジストリと、IPv4アドレスの枯渇

アフリカ以外の先進国はだいたいIPが枯渇してる
ただ、枯渇の宣言をしているが本当に枯渇したわけではなく、1677万個くらいは残ってる時点で枯渇を宣言して配布ポリシーを変更している

枯渇してもIPv4の需要はなくならない
どうやって手に入れるかというと、アドレス移転(組織間でのやり取り)の仕組みを使う
かつ、お金で売買する(オークションサイトもある)


## Destination NAT

利用の大半はSource NAT
特殊な用途では Destination NAT が必要

オンラインゲームのサーバーをLAN内に置いて、グローバルネットワークに公開するときに「ポートを開放する」という表現をするが、これはDestination NATのことを指す


Source NAT がLANから出ていくパケットのSource Address/Port を書き換えていたことの逆で
Destination NAT はルータのグローバルアドレスの特定ポートをDestination Adressとして外部インターネットから到来したパケットのDestinationを、Private Address + Port に書き換える

何でもかんでも書き換えるわけでなく、TCP/UDPパケットの特定の送信ポートに対する通信だけを書き換えてLANに転送すr

外部から到来するパケットにはサイバー攻撃を含む可能性があるため、ポート開放は慎重に


## Carrier Grade NAT

IPv4 アドレスが枯渇気味で逼迫してるので、NATをISPレベルで導入する仕組みが普及されている
それがCGN (Carrier Grade NAT)

プロバイダに契約している人々が、更に少数のグローバルIPを多くの家庭用ルーターにNATして共有する

CGNのプライベートアドレスは ISP シェアードアドレスと呼ばれる

ISPシェアードアドレスは予約されたアドレスレンジを使う 100.64.0.0/10
家庭用NATとは排他的存在ではなく、多段NATのような感じになる
既存のプライベートIPレンジをを使うと、重複が発生する可能性が出る

CGNのメリットは、主にISPにはある。(少ないグローバルIPで多くの顧客と契約できる)
ユーザーへのメリットはなく、デメリットとしてポート開放ができない。(ISPがポート開放を提供してれば話は別だが)

## モバイルネットワークはNAT?

モバイルネットワークにはCGNが積極的に使われている。
一人一台スマートフォンの時代ではIPを節約するのは当然と言える。
また、スマホでサーバー公開など一般に需要がないので、ポート開放できないというデメリットも許容しやすい。

## CGN のコスト
膨大なセッション情報を扱うのでCGNを行うルーター機器は高性能で高価と言われる。
導入のコストは低くないが、IPv4アドレスが希少になりすぎてコストよりもアドレス節約のメリットが上回った状況と言える。


### NAT まとめ

- IPv4 アドレスを節約するための技術
- Source NATが多く使われ、Destination NATは自作サーバーなど限定的な要素に使われる
- アドレス書き換えだけだと、戻りの通信の1:Nの対応が不可能なので、厳密にはPortも書き換えるNAPTになっていることがほとんど
- ICMP など、port を含まないパケットは identifier など別のフィールドを行き・戻り通信のアドレス対応付けに使うこともある


# ソケットプログラミング

ネットワークプログラミング
サーバーなど

Linux の Socket API を使うと簡単に実装できる
ソケット = ネットワークを抽象化した概念. ソケットに入力すると、通信先のソケットから出力される







